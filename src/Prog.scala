package torture

import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.HashMap
import Rand._

class ProgSeg(val name: String)
{
  var insts = new ArrayBuffer[Inst]

  override def toString = ((name + ":\n") /: insts.map((x) => "\t" + x + "\n"))(_ + _)
}

object ProgSeg
{
  var cnt = 0

  def apply() =
  {
    val res = new ProgSeg("pseg_" + cnt)
    cnt += 1
    res
  }
}

class Prog
{
  val xregs = new XRegsPool()
  val fregs = new FRegsPool()
  val seqs = new ArrayBuffer[InstSeq]
  val seqs_active = new ArrayBuffer[InstSeq]
  val progsegs = new ArrayBuffer[ProgSeg]

  def seqs_not_allocated = seqs.filter((x) => !x.allocated)
  def is_seqs_empty = seqs_not_allocated.length == 0
  def is_seqs_active_empty = seqs_active.length == 0

  def seqs_find_active(): Unit =
  {
    for (seq <- seqs_not_allocated)
    {
      xregs.backup()
      fregs.backup()

      if (seq.allocate_regs())
      {
        seqs_active += seq
      }
      else
      {
        xregs.restore()
        fregs.restore()

        return
      }
    }
  }

  def add_inst(inst: Inst) =
  {
    if (progsegs.length == 0)
      progsegs += ProgSeg()

    val filter = (x: Operand) =>
      x.isInstanceOf[Label] && x.asInstanceOf[Label].label.indexOf("patch") != -1
    val patch = inst.operands.indexWhere(filter)

    progsegs.last.insts += inst

    if (patch != -1)
    {
      progsegs.last.insts += ILLEGAL(Label("0x%08x" format rand_word))
      progsegs += ProgSeg()
      inst.operands(patch) = Label(progsegs.last.name)
    }
  }

  var far_branches = 0

  def resolve_far_branches =
  {
    var resolved = false

    val labels = new HashMap[String, Int]
    var line = 0

    labels += ("crash_backward" -> line)
    line += 35

    for (progseg <- progsegs)
    {
      labels += (progseg.name -> line)
      line += progseg.insts.length
    }

    labels += ("reg_dump" -> line)
    line += 35
    labels += ("crash_forward" -> line)

    val progsegs_insert = new ArrayBuffer[(ProgSeg, ProgSeg)]

    for (progseg <- progsegs)
    {
      val branches = new ArrayBuffer[Inst]
      line = labels(progseg.name)

      for (inst <- progseg.insts)
      {
        if (inst.is_la) line += 1
        if (inst.is_branch)
        {
          //println("%d: %d %s" format (line, math.abs(line - labels(inst.operands(2).asInstanceOf[Label].label)), inst))
          if (math.abs(line - labels(inst.operands(2).asInstanceOf[Label].label)) > 800)
            branches += inst
        }
        line += 1
      }

      // only split the first far branch in a progseg
      if (branches.length > 0)
      {
        val label = branches(0).operands(2)
        branches(0).operands(2) = Label("far_branch_" + far_branches)
        val idx_split = progseg.insts.indexOf(branches(0)) + 1
        val (insts, insts_split) = progseg.insts.splitAt(idx_split)
        insts += J(Label("far_branch_" + (far_branches+1)))
        progseg.insts = insts

        val progseg_fb0 = new ProgSeg("far_branch_" + far_branches)
        progseg_fb0.insts += J(label)
        progsegs_insert += ((progseg, progseg_fb0))
        val progseg_fb1 = new ProgSeg("far_branch_" + (far_branches+1))
        progseg_fb1.insts = insts_split
        progsegs_insert += ((progseg_fb0, progseg_fb1))

        far_branches += 2
        resolved = true
      }
    }

    for ((progseg, progseg_insert) <- progsegs_insert)
    {
      val idx_insert = progsegs.indexOf(progseg) + 1
      progsegs.insert(idx_insert, progseg_insert)
    }

    resolved
  }

  def names = List("xmem","xbranch","xalu")

  def code_body(nseqs: Int, memsize: Int, mix: Map[String, Int]) =
  {
    val name_to_seq = Map(
      "xmem" -> (() => new SeqMem(xregs, memsize)),
      "xbranch" -> (() => new SeqBranch(xregs)),
      "xalu" -> (() => new SeqALU(xregs)))

    val prob_tbl = new ArrayBuffer[(Int, () => InstSeq)]

    for ((name, prob) <- mix)
      prob_tbl += ((prob, name_to_seq(name)))

    for (i <- 0 to nseqs-1)
      seqs += InstSeq(memsize, prob_tbl)

    while (!is_seqs_empty)
    {
      seqs_find_active()

      while (!is_seqs_active_empty)
      {
        val seq = rand_pick(seqs_active)
        add_inst(seq.next_inst())

        if (seq.is_done)
        {
          seq.free_regs()
          seqs_active -= seq
        }
      }
    }

    progsegs.last.insts += J(Label("reg_dump"))
    rand_permute(progsegs)

    while (resolve_far_branches) {}

    ("" /: progsegs)(_ + _) + "\n"
  }

  def header(nseqs: Int, memsize: Int) =
  {
    "// random assembly code generated by RISC-V torture test generator\n" +
    "// nseqs = " + nseqs + "\n" +
    "// memsize = " + memsize + "\n" +
    "\n" +
    "#include \"test_riscv.h\"\n" +
    "\n" +
    "\tTEST_RISCV\n"
  }

  def code_header() =
  {
    "\n" +
    "\tTEST_CODEBEGIN\n" +
    "\n" +
    "\tj test_start\n" +
    "\n" +
    "crash_backward:\n" +
    "\tTEST_FAIL\n" +
    "\n" +
    "test_start:\n" +
    "\n" +
    init_regs() +
    "\tj pseg_0\n" +
    "\n"
  }

  def init_regs() =
  {
    var s = "sreg_init:\n"
    s += "\tla x31, sreg_init_data\n"
    for (i <- 1 to 31)
      s += "\tld x" + i + ", " + 8*i + "(x31)\n"
    s += "\n"
    s
  }

  def save_regs() =
  {
    var s = "reg_dump:\n"
    val r = rand_range(1, 31)
    s += "\tla x" + r + ", sreg_output_data\n"
    for (i <- 1 to 31)
      if (i != r && xregs.hwregs(i).is_visible)
        s += "\tsd x" + i + ", " + 8*i + "(x" + r + ")\n"
    s += "\n"
    s
  }

  def code_footer() =
  {
    save_regs() +
    "\tj test_end\n" +
    "\n" +
    "crash_forward:\n" +
    "\tTEST_FAIL\n" +
    "\n" +
    "test_end:\n" +
    "\tTEST_PASS\n" +
    "\n" +
    "\tTEST_CODEEND\n" +
    "\n"
  }

  def data_header() =
  {
    "\t.data\n" +
    "\t.align 8\n" +
    "\n"
  }

  def init_regs_data() =
  {
    var s = "sreg_init_data:\n"
    for (i <- 0 to 31)
      s += ("reg_x" + i + "_init:\t.dword " + "0x%016x\n" format rand_biased)
    s += "\n"
    s
  }

  def output_regs_data() =
  {
    var s = "sreg_output_data:\n"
    for (i <- 0 to 31)
      s += "reg_x" + i + "_output:\t.dword 0x%016x\n" format rand_dword
    s += "\n"
    s
  }

  def output_mem_data(memsize: Int) =
  {
    var s = "\t.align 8\n"
    s += "test_memory:\n"
    for (i <- 0 to memsize/8/2)
      s += "\t.dword 0x%016x, 0x%016x\n" format (rand_dword, rand_dword)
    s += "\n"
    s
  }

  def data_input() =
  {
    init_regs_data()
  }

  def data_output(memsize: Int) =
  {
    "\tTEST_DATABEGIN\n" +
    "\n" +
    output_regs_data() +
    output_mem_data(memsize) +
    "\tTEST_DATAEND\n"
  }

  def data_footer() = ""

  def generate(nseqs: Int, memsize: Int, mix: Map[String, Int]) =
  {
    header(nseqs, memsize) +
    code_header() +
    code_body(nseqs, memsize, mix) +
    code_footer() +
    data_header() +
    data_input() +
    data_output(memsize) +
    data_footer()
  }
}
