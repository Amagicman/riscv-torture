package torture

import scala.collection.mutable.ArrayBuffer
import Rand._

class ProgSeg(val name: String)
{
  val insts = new ArrayBuffer[Inst]

  override def toString = ((name + ":\n") /: insts.map((x) => "\t" + x + "\n"))(_ + _)
}

object ProgSeg
{
  var cnt = 0

  def apply() =
  {
    val res = new ProgSeg("pseg_" + cnt)
    cnt += 1
    res
  }
}

class Prog
{
  val hwrp = new HWRegPool()
  val seqs = new ArrayBuffer[Seq]
  val seqs_active = new ArrayBuffer[Seq]
  val progsegs = new ArrayBuffer[ProgSeg]

  def seqs_not_allocated = seqs.filter((x) => !x.allocated)
  def is_seqs_empty = seqs_not_allocated.length == 0
  def is_seqs_active_empty = seqs_active.length == 0

  def seqs_find_active(): Unit =
  {
    for (seq <- seqs_not_allocated)
    {
      if (seq.allocate_regs(hwrp, false))
      {
        seq.allocate_regs(hwrp, true)
        seqs_active += seq
      }
      else
      {
        return
      }
    }
  }

  def add_inst(inst: Inst) =
  {
    if (progsegs.length == 0)
      progsegs += ProgSeg()

    val filter = (x: Operand) =>
      x.isInstanceOf[Label] && x.asInstanceOf[Label].label.indexOf("patch") != -1
    val patch = inst.operands.indexWhere(filter)

    progsegs.last.insts += inst

    if (patch != -1)
    {
      progsegs += ProgSeg()
      inst.operands(patch) = Label(progsegs.last.name)
    }
  }

  def code_body(nseqs: Int, memsize: Int) =
  {
    hwrp.init()

    for (i <- 0 to nseqs-1)
      seqs += Seq(memsize)

    while (!is_seqs_empty)
    {
      seqs_find_active()

      while (!is_seqs_active_empty)
      {
        val seq = rand_pick(seqs_active)
        add_inst(seq.next_inst())

        if (seq.is_done)
        {
          seq.free_regs()
          seqs_active -= seq
        }
      }
    }

    progsegs.last.insts += J(Label("reg_dump"))
    rand_permute(progsegs)

    ("" /: progsegs)(_ + _) + "\n"
  }

  def header(nseqs: Int, memsize: Int) =
  {
    "// random assembly code generated by RISC-V torture test generator\n" +
    "// nseqs = " + nseqs + "\n" +
    "// memsize = " + memsize + "\n" +
    "\n" +
    "#include <riscvtest.h>\n" +
    "\n" +
    "\tTEST_RISCV\n"
  }

  def code_header() =
  {
    "\n" +
    "\tTEST_CODEBEGIN\n" +
    "\n" +
    "\tj test_start\n" +
    "\n" +
    "crash_backward:\n" +
    "\tTEST_CRASH\n" +
    "\n" +
    "test_start:\n" +
    "\n" +
    init_regs() +
    "\tj pseg_0\n" +
    "\n"
  }

  def init_regs() =
  {
    var s = "sreg_init:\n"
    s += "\tla x31, sreg_init_data\n"
    for (i <- 1 to 31)
      s += "\tld x" + i + ", " + 4*i + "(x31)\n"
    s += "\n"
    s
  }

  def save_regs() =
  {
    var s = "reg_dump:\n"
    val r = rand_range(1, 31)
    s += "\tla x" + r + ", sreg_output_data\n"
    for (i <- 1 to 31)
      if (i != r && hwrp.hwregs(i).is_visible)
        s += "\tsd x" + i + ", " + 4*i + "(x" + r + ")\n"
    s += "\n"
    s
  }

  def code_footer() =
  {
    save_regs() +
    "\tj test_end\n" +
    "\n" +
    "crash_forward:\n" +
    "\tTEST_CRASH\n" +
    "\n" +
    "test_end:\n" +
    "\tTEST_CODEEND\n" +
    "\n"
  }

  def data_header() =
  {
    "\t.data\n" +
    "\t.align 8\n" +
    "\n"
  }

  def init_regs_data() =
  {
    var s = "sreg_init_data:\n"
    for (i <- 0 to 31)
      s += ("reg_x" + i + "_init:\t.dword " + "0x%016x\n" format rand_biased)
    s += "\n"
    s
  }

  def output_regs_data() =
  {
    var s = "sreg_output_data:\n"
    for (i <- 0 to 31)
      s += "reg_x" + i + "_output:\t.dword 0x%016x\n" format rand_dword
    s += "\n"
    s
  }

  def output_mem_data(memsize: Int) =
  {
    var s = "\t.align 8\n"
    s += "test_memory:\n"
    for (i <- 0 to memsize/8/2)
      s += "\t.dword 0x%016x 0x%016x\n" format (rand_dword, rand_dword)
    s += "\n"
    s
  }

  def data_input() =
  {
    init_regs_data()
  }

  def data_output(memsize: Int) =
  {
    "\tTEST_DATABEGIN\n" +
    "\n" +
    output_regs_data() +
    output_mem_data(memsize) +
    "\tTEST_DATAEND\n"
  }

  def data_footer() = ""

  def generate(nseqs: Int, memsize: Int) =
  {
    header(nseqs, memsize) +
    code_header() +
    code_body(nseqs, memsize) +
    code_footer() +
    data_header() +
    data_input() +
    data_output(memsize) +
    data_footer()
  }
}
